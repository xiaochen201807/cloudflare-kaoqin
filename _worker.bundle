------formdata-undici-006884689923
Content-Disposition: form-data; name="metadata"

{"main_module":"functionsWorker-0.2211879933211467.js"}
------formdata-undici-006884689923
Content-Disposition: form-data; name="functionsWorker-0.2211879933211467.js"; filename="functionsWorker-0.2211879933211467.js"
Content-Type: application/javascript+module

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// ../node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;
var isCryptoKey = /* @__PURE__ */ __name((key) => key instanceof CryptoKey, "isCryptoKey");

// ../node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var MAX_INT32 = 2 ** 32;
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf;
}
__name(concat, "concat");

// ../node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = /* @__PURE__ */ __name((input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
}, "encodeBase64");
var encode = /* @__PURE__ */ __name((input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}, "encode");

// ../node_modules/jose/dist/browser/util/errors.js
var JOSEError = class extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message2) {
    var _a;
    super(message2);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
  }
};
__name(JOSEError, "JOSEError");
var JOSENotSupported = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
};
__name(JOSENotSupported, "JOSENotSupported");
var JWSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
};
__name(JWSInvalid, "JWSInvalid");
var JWTInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
};
__name(JWTInvalid, "JWTInvalid");

// ../node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
__name(unusable, "unusable");
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
__name(isAlgorithm, "isAlgorithm");
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
__name(getHashLength, "getHashLength");
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
__name(getNamedCurve, "getNamedCurve");
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
__name(checkUsage, "checkUsage");
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
__name(checkSigCryptoKey, "checkSigCryptoKey");

// ../node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types2) {
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
__name(message, "message");
var invalid_key_input_default = /* @__PURE__ */ __name((actual, ...types2) => {
  return message("Key must be ", actual, ...types2);
}, "default");
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}
__name(withAlg, "withAlg");

// ../node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default = /* @__PURE__ */ __name((key) => {
  return isCryptoKey(key);
}, "default");
var types = ["CryptoKey"];

// ../node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint = /* @__PURE__ */ __name((...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
}, "isDisjoint");
var is_disjoint_default = isDisjoint;

// ../node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
__name(isObjectLike, "isObjectLike");
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
__name(isObject, "isObject");

// ../node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default = /* @__PURE__ */ __name((alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
}, "default");

// ../node_modules/jose/dist/browser/runtime/asn1.js
var findOid = /* @__PURE__ */ __name((keyData, oid, from = 0) => {
  if (from === 0) {
    oid.unshift(oid.length);
    oid.unshift(6);
  }
  let i = keyData.indexOf(oid[0], from);
  if (i === -1)
    return false;
  const sub = keyData.subarray(i, i + oid.length);
  if (sub.length !== oid.length)
    return false;
  return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);
}, "findOid");
var getNamedCurve2 = /* @__PURE__ */ __name((keyData) => {
  switch (true) {
    case findOid(keyData, [42, 134, 72, 206, 61, 3, 1, 7]):
      return "P-256";
    case findOid(keyData, [43, 129, 4, 0, 34]):
      return "P-384";
    case findOid(keyData, [43, 129, 4, 0, 35]):
      return "P-521";
    case findOid(keyData, [43, 101, 110]):
      return "X25519";
    case findOid(keyData, [43, 101, 111]):
      return "X448";
    case findOid(keyData, [43, 101, 112]):
      return "Ed25519";
    case findOid(keyData, [43, 101, 113]):
      return "Ed448";
    default:
      throw new JOSENotSupported("Invalid or unsupported EC Key Curve or OKP Key Sub Type");
  }
}, "getNamedCurve");
var genericImport = /* @__PURE__ */ __name(async (replace, keyFormat, pem, alg, options) => {
  var _a;
  let algorithm;
  let keyUsages;
  const keyData = new Uint8Array(atob(pem.replace(replace, "")).split("").map((c) => c.charCodeAt(0)));
  const isPublic = keyFormat === "spki";
  switch (alg) {
    case "PS256":
    case "PS384":
    case "PS512":
      algorithm = { name: "RSA-PSS", hash: `SHA-${alg.slice(-3)}` };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${alg.slice(-3)}` };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      algorithm = {
        name: "RSA-OAEP",
        hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`
      };
      keyUsages = isPublic ? ["encrypt", "wrapKey"] : ["decrypt", "unwrapKey"];
      break;
    case "ES256":
      algorithm = { name: "ECDSA", namedCurve: "P-256" };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "ES384":
      algorithm = { name: "ECDSA", namedCurve: "P-384" };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "ES512":
      algorithm = { name: "ECDSA", namedCurve: "P-521" };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      const namedCurve = getNamedCurve2(keyData);
      algorithm = namedCurve.startsWith("P-") ? { name: "ECDH", namedCurve } : { name: namedCurve };
      keyUsages = isPublic ? [] : ["deriveBits"];
      break;
    }
    case "EdDSA":
      algorithm = { name: getNamedCurve2(keyData) };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    default:
      throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
  }
  return webcrypto_default.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);
}, "genericImport");
var fromPKCS8 = /* @__PURE__ */ __name((pem, alg, options) => {
  return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, "pkcs8", pem, alg, options);
}, "fromPKCS8");

// ../node_modules/jose/dist/browser/key/import.js
async function importPKCS8(pkcs8, alg, options) {
  if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
    throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
  }
  return fromPKCS8(pkcs8, alg, options);
}
__name(importPKCS8, "importPKCS8");

// ../node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck = /* @__PURE__ */ __name((alg, key) => {
  if (key instanceof Uint8Array)
    return;
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
}, "symmetricTypeCheck");
var asymmetricTypeCheck = /* @__PURE__ */ __name((alg, key, usage) => {
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types));
  }
  if (key.type === "secret") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
  }
}, "asymmetricTypeCheck");
var checkKeyType = /* @__PURE__ */ __name((alg, key, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key);
  } else {
    asymmetricTypeCheck(alg, key, usage);
  }
}, "checkKeyType");
var check_key_type_default = checkKeyType;

// ../node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
__name(validateCrit, "validateCrit");
var validate_crit_default = validateCrit;

// ../node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
__name(subtleDsa, "subtleDsa");

// ../node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
__name(getCryptoKey, "getCryptoKey");

// ../node_modules/jose/dist/browser/lib/epoch.js
var epoch_default = /* @__PURE__ */ __name((date) => Math.floor(date.getTime() / 1e3), "default");

// ../node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
var secs_default = /* @__PURE__ */ __name((str) => {
  const matched = REGEX.exec(str);
  if (!matched) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[1]);
  const unit = matched[2].toLowerCase();
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      return Math.round(value);
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      return Math.round(value * minute);
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      return Math.round(value * hour);
    case "day":
    case "days":
    case "d":
      return Math.round(value * day);
    case "week":
    case "weeks":
    case "w":
      return Math.round(value * week);
    default:
      return Math.round(value * year);
  }
}, "default");

// ../node_modules/jose/dist/browser/runtime/sign.js
var sign = /* @__PURE__ */ __name(async (alg, key, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
}, "sign");
var sign_default = sign;

// ../node_modules/jose/dist/browser/jws/flattened/sign.js
var FlattenedSign = class {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder.encode(encode(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder.encode("");
    }
    const data = concat(protectedHeader, encoder.encode("."), payload);
    const signature = await sign_default(alg, key, data);
    const jws = {
      signature: encode(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
};
__name(FlattenedSign, "FlattenedSign");

// ../node_modules/jose/dist/browser/jws/compact/sign.js
var CompactSign = class {
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this._flattened.sign(key, options);
    if (jws.payload === void 0) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
};
__name(CompactSign, "CompactSign");

// ../node_modules/jose/dist/browser/jwt/produce.js
var ProduceJWT = class {
  constructor(payload) {
    if (!isObject(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: input };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: input };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
    } else {
      this._payload = { ...this._payload, iat: input };
    }
    return this;
  }
};
__name(ProduceJWT, "ProduceJWT");

// ../node_modules/jose/dist/browser/jwt/sign.js
var SignJWT = class extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    var _a;
    const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
};
__name(SignJWT, "SignJWT");

// oauth/callback.js
function createErrorPage(title, message2, details = null, returnUrl = "/login.html") {
  return `<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title} - \u8003\u52E4\u7CFB\u7EDF</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }
    .error-container { max-width: 600px; margin: 50px auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    .error-icon { font-size: 48px; color: #e74c3c; text-align: center; margin-bottom: 20px; }
    h1 { color: #e74c3c; text-align: center; margin-bottom: 20px; }
    .message { color: #666; line-height: 1.6; margin-bottom: 20px; }
    .details { background: #f8f9fa; padding: 15px; border-radius: 4px; margin: 20px 0; font-family: monospace; font-size: 14px; }
    .actions { text-align: center; margin-top: 30px; }
    .btn { display: inline-block; padding: 10px 20px; background: #3498db; color: white; text-decoration: none; border-radius: 4px; margin: 0 10px; }
    .btn:hover { background: #2980b9; }
  </style>
</head>
<body>
  <div class="error-container">
    <div class="error-icon">\u26A0\uFE0F</div>
    <h1>${title}</h1>
    <div class="message">${message2}</div>
    ${details ? `<div class="details">${details}</div>` : ""}
    <div class="actions">
      <a href="${returnUrl}" class="btn">\u8FD4\u56DE\u767B\u5F55</a>
      <a href="/api/health" class="btn">\u7CFB\u7EDF\u72B6\u6001</a>
    </div>
  </div>
</body>
</html>`;
}
__name(createErrorPage, "createErrorPage");
function logError(context, error, additionalInfo = {}) {
  const logData = {
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    error: error.message || error,
    stack: error.stack,
    url: context.request?.url,
    userAgent: context.request?.headers.get("User-Agent"),
    ...additionalInfo
  };
  console.error("OAuth Callback Error:", JSON.stringify(logData, null, 2));
}
__name(logError, "logError");
async function onRequest(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  const code = url.searchParams.get("code");
  const state = url.searchParams.get("state");
  const error = url.searchParams.get("error");
  const errorDescription = url.searchParams.get("error_description");
  if (error) {
    logError(context, new Error(`OAuth Provider Error: ${error}`), {
      error,
      errorDescription,
      state
    });
    const errorPage = createErrorPage(
      "OAuth \u8BA4\u8BC1\u5931\u8D25",
      `\u8BA4\u8BC1\u8FC7\u7A0B\u4E2D\u53D1\u751F\u9519\u8BEF\uFF1A${errorDescription || error}`,
      `\u9519\u8BEF\u4EE3\u7801: ${error}
\u72B6\u6001: ${state || "N/A"}`
    );
    return new Response(errorPage, {
      status: 400,
      headers: { "Content-Type": "text/html; charset=utf-8" }
    });
  }
  if (!code) {
    logError(context, new Error("Authorization code missing"), { state });
    const errorPage = createErrorPage(
      "\u6388\u6743\u7801\u7F3A\u5931",
      "OAuth \u8BA4\u8BC1\u8FC7\u7A0B\u4E2D\u672A\u6536\u5230\u6388\u6743\u7801\uFF0C\u8BF7\u91CD\u8BD5\u767B\u5F55\u3002",
      `\u72B6\u6001: ${state || "N/A"}
\u8BF7\u68C0\u67E5OAuth\u5E94\u7528\u914D\u7F6E\u662F\u5426\u6B63\u786E`
    );
    return new Response(errorPage, {
      status: 400,
      headers: { "Content-Type": "text/html; charset=utf-8" }
    });
  }
  const cookieHeader = request.headers.get("Cookie") || "";
  const cookies = Object.fromEntries(
    cookieHeader.split("; ").map((c) => {
      const [name, ...value] = c.split("=");
      return [name, value.join("=")];
    })
  );
  if (cookies.gitee_oauth_state) {
    return handleGiteeCallback(context, code, state, cookies);
  } else {
    return handleGitHubCallback(context, code, state, cookies);
  }
}
__name(onRequest, "onRequest");
async function handleGitHubCallback(context, code, state, cookies) {
  const { env } = context;
  try {
    if (state !== cookies.oauth_state) {
      logError(context, new Error("OAuth state mismatch"), {
        expectedState: cookies.oauth_state,
        receivedState: state,
        provider: "github"
      });
      const errorPage = createErrorPage(
        "\u72B6\u6001\u9A8C\u8BC1\u5931\u8D25",
        "OAuth \u72B6\u6001\u9A8C\u8BC1\u5931\u8D25\uFF0C\u53EF\u80FD\u5B58\u5728\u5B89\u5168\u98CE\u9669\u3002\u8BF7\u91CD\u65B0\u767B\u5F55\u3002",
        `\u671F\u671B\u72B6\u6001: ${cookies.oauth_state || "N/A"}
\u63A5\u6536\u72B6\u6001: ${state || "N/A"}`
      );
      return new Response(errorPage, {
        status: 403,
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    }
    const selectedRedirectUri = cookies.selected_redirect_uri || env.REDIRECT_URI?.split(",")[0];
    if (!selectedRedirectUri) {
      logError(context, new Error("No redirect URI configured"), {
        provider: "github",
        envRedirectUri: env.REDIRECT_URI
      });
      const errorPage = createErrorPage(
        "\u914D\u7F6E\u9519\u8BEF",
        "OAuth \u56DE\u8C03\u5730\u5740\u672A\u6B63\u786E\u914D\u7F6E\u3002",
        "\u8BF7\u68C0\u67E5 REDIRECT_URI \u73AF\u5883\u53D8\u91CF\u914D\u7F6E"
      );
      return new Response(errorPage, {
        status: 500,
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    }
    const tokenResponse = await fetch("https://github.com/login/oauth/access_token", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      body: JSON.stringify({
        client_id: env.GITHUB_CLIENT_ID,
        client_secret: env.GITHUB_CLIENT_SECRET,
        code,
        redirect_uri: selectedRedirectUri
      })
    });
    if (!tokenResponse.ok) {
      logError(context, new Error(`GitHub token request failed: ${tokenResponse.status}`), {
        provider: "github",
        status: tokenResponse.status,
        statusText: tokenResponse.statusText
      });
      const errorPage = createErrorPage(
        "\u4EE4\u724C\u83B7\u53D6\u5931\u8D25",
        "\u65E0\u6CD5\u4ECE GitHub \u83B7\u53D6\u8BBF\u95EE\u4EE4\u724C\u3002",
        `HTTP\u72B6\u6001: ${tokenResponse.status}
\u8BF7\u68C0\u67E5OAuth\u5E94\u7528\u914D\u7F6E`
      );
      return new Response(errorPage, {
        status: 500,
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    }
    const tokenData = await tokenResponse.json();
    if (!tokenData.access_token) {
      logError(context, new Error("GitHub access token missing"), {
        provider: "github",
        tokenData,
        error: tokenData.error,
        errorDescription: tokenData.error_description
      });
      const errorPage = createErrorPage(
        "\u8BBF\u95EE\u4EE4\u724C\u65E0\u6548",
        "GitHub \u8FD4\u56DE\u7684\u8BBF\u95EE\u4EE4\u724C\u65E0\u6548\u3002",
        `\u9519\u8BEF: ${tokenData.error || "unknown"}
\u63CF\u8FF0: ${tokenData.error_description || "N/A"}`
      );
      return new Response(errorPage, {
        status: 500,
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    }
    const userResponse = await fetch("https://api.github.com/user", {
      headers: {
        "Authorization": `Bearer ${tokenData.access_token}`
      }
    });
    if (!userResponse.ok) {
      logError(context, new Error(`GitHub user info request failed: ${userResponse.status}`), {
        provider: "github",
        status: userResponse.status,
        statusText: userResponse.statusText
      });
      const errorPage = createErrorPage(
        "\u7528\u6237\u4FE1\u606F\u83B7\u53D6\u5931\u8D25",
        "\u65E0\u6CD5\u4ECE GitHub \u83B7\u53D6\u7528\u6237\u4FE1\u606F\u3002",
        `HTTP\u72B6\u6001: ${userResponse.status}
\u8BF7\u68C0\u67E5\u8BBF\u95EE\u4EE4\u724C\u6743\u9650`
      );
      return new Response(errorPage, {
        status: 500,
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    }
    const userData = await userResponse.json();
    if (!userData.id) {
      logError(context, new Error("Invalid GitHub user data"), {
        provider: "github",
        userData
      });
      const errorPage = createErrorPage(
        "\u7528\u6237\u6570\u636E\u65E0\u6548",
        "GitHub \u8FD4\u56DE\u7684\u7528\u6237\u6570\u636E\u65E0\u6548\u3002",
        "\u8BF7\u91CD\u8BD5\u767B\u5F55\u6216\u8054\u7CFB\u7BA1\u7406\u5458"
      );
      return new Response(errorPage, {
        status: 500,
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    }
    const sessionId = crypto.randomUUID();
    const session = {
      user: {
        ...userData,
        provider: "github"
      },
      expiresAt: Date.now() + 7 * 24 * 60 * 60 * 1e3
      // 一周后过期
    };
    await context.env.SESSIONS.put(sessionId, JSON.stringify(session), {
      expirationTtl: 7 * 24 * 60 * 60
      // 一周有效期
    });
    const returnTo = cookies.return_to || "/";
    const headers = new Headers({
      "Location": returnTo
    });
    headers.append("Set-Cookie", `session_id=${sessionId}; Path=/; Secure; HttpOnly; Max-Age=${7 * 24 * 60 * 60}; SameSite=Lax`);
    return new Response("", {
      status: 302,
      headers
    });
  } catch (error) {
    logError(context, error, {
      provider: "github",
      code,
      state
    });
    const errorPage = createErrorPage(
      "GitHub \u767B\u5F55\u5931\u8D25",
      "\u5904\u7406 GitHub \u767B\u5F55\u65F6\u53D1\u751F\u672A\u77E5\u9519\u8BEF\u3002",
      `\u9519\u8BEF\u4FE1\u606F: ${error.message}
\u8BF7\u91CD\u8BD5\u767B\u5F55\u6216\u8054\u7CFB\u7BA1\u7406\u5458`
    );
    return new Response(errorPage, {
      status: 500,
      headers: { "Content-Type": "text/html; charset=utf-8" }
    });
  }
}
__name(handleGitHubCallback, "handleGitHubCallback");
async function handleGiteeCallback(context, code, state, cookies) {
  const { env } = context;
  try {
    if (state !== cookies.gitee_oauth_state) {
      logError(context, new Error("Gitee OAuth state mismatch"), {
        expectedState: cookies.gitee_oauth_state,
        receivedState: state,
        provider: "gitee"
      });
      const errorPage = createErrorPage(
        "\u72B6\u6001\u9A8C\u8BC1\u5931\u8D25",
        "Gitee OAuth \u72B6\u6001\u9A8C\u8BC1\u5931\u8D25\uFF0C\u53EF\u80FD\u5B58\u5728\u5B89\u5168\u98CE\u9669\u3002\u8BF7\u91CD\u65B0\u767B\u5F55\u3002",
        `\u671F\u671B\u72B6\u6001: ${cookies.gitee_oauth_state || "N/A"}
\u63A5\u6536\u72B6\u6001: ${state || "N/A"}`
      );
      return new Response(errorPage, {
        status: 403,
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    }
    const tokenResponse = await fetch(`https://gitee.com/oauth/token`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      body: JSON.stringify({
        grant_type: "authorization_code",
        code,
        client_id: env.GITEE_CLIENT_ID,
        client_secret: env.GITEE_CLIENT_SECRET,
        redirect_uri: env.GITEE_REDIRECT_URI
      })
    });
    if (!tokenResponse.ok) {
      logError(context, new Error(`Gitee token request failed: ${tokenResponse.status}`), {
        provider: "gitee",
        status: tokenResponse.status,
        statusText: tokenResponse.statusText
      });
      const errorPage = createErrorPage(
        "\u4EE4\u724C\u83B7\u53D6\u5931\u8D25",
        "\u65E0\u6CD5\u4ECE Gitee \u83B7\u53D6\u8BBF\u95EE\u4EE4\u724C\u3002",
        `HTTP\u72B6\u6001: ${tokenResponse.status}
\u8BF7\u68C0\u67E5OAuth\u5E94\u7528\u914D\u7F6E`
      );
      return new Response(errorPage, {
        status: 500,
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    }
    const tokenData = await tokenResponse.json();
    if (!tokenData.access_token) {
      logError(context, new Error("Gitee access token missing"), {
        provider: "gitee",
        tokenData,
        error: tokenData.error,
        errorDescription: tokenData.error_description
      });
      const errorPage = createErrorPage(
        "\u8BBF\u95EE\u4EE4\u724C\u65E0\u6548",
        "Gitee \u8FD4\u56DE\u7684\u8BBF\u95EE\u4EE4\u724C\u65E0\u6548\u3002",
        `\u9519\u8BEF: ${tokenData.error || "unknown"}
\u63CF\u8FF0: ${tokenData.error_description || "N/A"}`
      );
      return new Response(errorPage, {
        status: 500,
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    }
    const userResponse = await fetch(`https://gitee.com/api/v5/user?access_token=${tokenData.access_token}`, {
      method: "GET"
    });
    if (!userResponse.ok) {
      logError(context, new Error(`Gitee user info request failed: ${userResponse.status}`), {
        provider: "gitee",
        status: userResponse.status,
        statusText: userResponse.statusText
      });
      const errorPage = createErrorPage(
        "\u7528\u6237\u4FE1\u606F\u83B7\u53D6\u5931\u8D25",
        "\u65E0\u6CD5\u4ECE Gitee \u83B7\u53D6\u7528\u6237\u4FE1\u606F\u3002",
        `HTTP\u72B6\u6001: ${userResponse.status}
\u8BF7\u68C0\u67E5\u8BBF\u95EE\u4EE4\u724C\u6743\u9650`
      );
      return new Response(errorPage, {
        status: 500,
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    }
    const userData = await userResponse.json();
    if (!userData.id) {
      logError(context, new Error("Invalid Gitee user data"), {
        provider: "gitee",
        userData
      });
      const errorPage = createErrorPage(
        "\u7528\u6237\u6570\u636E\u65E0\u6548",
        "Gitee \u8FD4\u56DE\u7684\u7528\u6237\u6570\u636E\u65E0\u6548\u3002",
        "\u8BF7\u91CD\u8BD5\u767B\u5F55\u6216\u8054\u7CFB\u7BA1\u7406\u5458"
      );
      return new Response(errorPage, {
        status: 500,
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    }
    const sessionId = crypto.randomUUID();
    const session = {
      user: {
        id: userData.id,
        login: userData.login,
        name: userData.name || userData.login,
        avatar_url: userData.avatar_url,
        provider: "gitee"
      },
      expiresAt: Date.now() + 7 * 24 * 60 * 60 * 1e3
      // 一周后过期
    };
    await context.env.SESSIONS.put(sessionId, JSON.stringify(session), {
      expirationTtl: 7 * 24 * 60 * 60
      // 一周有效期
    });
    const returnTo = cookies.gitee_return_to || "/";
    const headers = new Headers({
      "Location": returnTo
    });
    headers.append("Set-Cookie", `session_id=${sessionId}; Path=/; Secure; HttpOnly; Max-Age=${7 * 24 * 60 * 60}; SameSite=Lax`);
    return new Response("", {
      status: 302,
      headers
    });
  } catch (error) {
    logError(context, error, {
      provider: "gitee",
      code,
      state
    });
    const errorPage = createErrorPage(
      "Gitee \u767B\u5F55\u5931\u8D25",
      "\u5904\u7406 Gitee \u767B\u5F55\u65F6\u53D1\u751F\u672A\u77E5\u9519\u8BEF\u3002",
      `\u9519\u8BEF\u4FE1\u606F: ${error.message}
\u8BF7\u91CD\u8BD5\u767B\u5F55\u6216\u8054\u7CFB\u7BA1\u7406\u5458`
    );
    return new Response(errorPage, {
      status: 500,
      headers: { "Content-Type": "text/html; charset=utf-8" }
    });
  }
}
__name(handleGiteeCallback, "handleGiteeCallback");

// api/[routes].js
function createErrorResponse(message2, statusCode = 500, details = null) {
  const errorResponse = {
    success: false,
    error: {
      message: message2,
      code: statusCode,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }
  };
  if (details) {
    errorResponse.error.details = details;
  }
  return new Response(
    JSON.stringify(errorResponse),
    {
      status: statusCode,
      headers: { "Content-Type": "application/json" }
    }
  );
}
__name(createErrorResponse, "createErrorResponse");
function createSuccessResponse(data, statusCode = 200) {
  return new Response(
    JSON.stringify({
      success: true,
      data,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }),
    {
      status: statusCode,
      headers: { "Content-Type": "application/json" }
    }
  );
}
__name(createSuccessResponse, "createSuccessResponse");
function validateRequiredEnvVars(env, requiredVars) {
  const missing = [];
  for (const varName of requiredVars) {
    if (!env[varName]) {
      missing.push(varName);
    }
  }
  return missing;
}
__name(validateRequiredEnvVars, "validateRequiredEnvVars");
function validateJWTConfig(env) {
  const algorithm = env.JWT_ALGORITHM || "HS256";
  const errors = [];
  if (!["HS256", "RS256"].includes(algorithm)) {
    errors.push("JWT_ALGORITHM must be either 'HS256' or 'RS256'");
  }
  if (algorithm === "HS256") {
    if (!env.JWT_SECRET) {
      errors.push("JWT_SECRET is required when using HS256 algorithm");
    } else if (env.JWT_SECRET.length < 32) {
      errors.push("JWT_SECRET must be at least 32 characters long for security");
    }
  } else if (algorithm === "RS256") {
    if (!env.JWT_PRIVATE_KEY) {
      errors.push("JWT_PRIVATE_KEY is required when using RS256 algorithm");
    }
    if (!env.JWT_PUBLIC_KEY) {
      errors.push("JWT_PUBLIC_KEY is required when using RS256 algorithm");
    }
    if (env.JWT_PRIVATE_KEY && !env.JWT_PRIVATE_KEY.includes("-----BEGIN PRIVATE KEY-----")) {
      errors.push("JWT_PRIVATE_KEY must be in valid PEM format");
    }
    if (env.JWT_PUBLIC_KEY && !env.JWT_PUBLIC_KEY.includes("-----BEGIN PUBLIC KEY-----")) {
      errors.push("JWT_PUBLIC_KEY must be in valid PEM format");
    }
  }
  return errors;
}
__name(validateJWTConfig, "validateJWTConfig");
function validateCriticalEnvVars(env) {
  const criticalVars = [
    "GITHUB_CLIENT_ID",
    "GITHUB_CLIENT_SECRET",
    "REDIRECT_URI",
    "GITEE_CLIENT_ID",
    "GITEE_CLIENT_SECRET",
    "GITEE_REDIRECT_URI"
  ];
  const missing = validateRequiredEnvVars(env, criticalVars);
  if (missing.length > 0) {
    return createErrorResponse(
      "Critical environment variables are missing. Please configure all required OAuth settings.",
      503,
      {
        missing,
        hint: "Check your Cloudflare Dashboard environment variables configuration",
        documentation: "See setup-env.md for detailed configuration instructions"
      }
    );
  }
  const jwtErrors = validateJWTConfig(env);
  if (jwtErrors.length > 0) {
    return createErrorResponse(
      "JWT configuration is invalid",
      503,
      {
        errors: jwtErrors,
        hint: "Check your JWT_ALGORITHM and corresponding keys configuration",
        documentation: "See setup-env.md for JWT configuration instructions"
      }
    );
  }
  return null;
}
__name(validateCriticalEnvVars, "validateCriticalEnvVars");
async function onRequest2(context) {
  const { request, env, params } = context;
  const url = new URL(request.url);
  const path = url.pathname;
  if (path !== "/api/health") {
    const validationError = validateCriticalEnvVars(env);
    if (validationError) {
      return validationError;
    }
  }
  const session = await getUserSession(context);
  if (path === "/api/user") {
    return handleUserInfo(context, session);
  }
  if (path === "/api/config") {
    return handleConfig(context);
  }
  if (path === "/api/submit-location" && request.method === "POST") {
    return handleSubmitLocation(context, session);
  }
  if (path === "/api/refresh-token") {
    return handleTokenRefresh(context, session);
  }
  if (path === "/api/logout") {
    return handleLogout(context);
  }
  if (path === "/api/health") {
    return handleHealthCheck(context);
  }
  return createErrorResponse("API endpoint not found", 404);
}
__name(onRequest2, "onRequest");
async function getUserSession(context) {
  const { request, env } = context;
  const cookieHeader = request.headers.get("Cookie") || "";
  const cookies = Object.fromEntries(
    cookieHeader.split("; ").map((c) => {
      const [name, ...value] = c.split("=");
      return [name, value.join("=")];
    })
  );
  const sessionId = cookies.session_id;
  if (!sessionId)
    return null;
  const sessionData = await env.SESSIONS.get(sessionId);
  if (!sessionData)
    return null;
  try {
    const session = JSON.parse(sessionData);
    if (session.expiresAt < Date.now()) {
      await env.SESSIONS.delete(sessionId);
      return null;
    }
    return session;
  } catch (e) {
    return null;
  }
}
__name(getUserSession, "getUserSession");
function handleUserInfo(context, session) {
  if (!session) {
    return new Response(
      JSON.stringify({ success: false, message: "\u672A\u6388\u6743\u8BBF\u95EE" }),
      {
        status: 401,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
  return new Response(
    JSON.stringify({ success: true, user: session.user }),
    {
      status: 200,
      headers: { "Content-Type": "application/json" }
    }
  );
}
__name(handleUserInfo, "handleUserInfo");
function handleConfig(context) {
  const { env } = context;
  return new Response(
    JSON.stringify({
      success: true,
      config: {
        apiEndpoints: {
          submitLocation: "/api/submit-location",
          refreshToken: "/api/refresh-token"
        }
      }
    }),
    {
      status: 200,
      headers: { "Content-Type": "application/json" }
    }
  );
}
__name(handleConfig, "handleConfig");
async function handleSubmitLocation(context, session) {
  const { request, env } = context;
  try {
    const requestData = await request.json();
    let data = { ...requestData };
    if (session) {
      data.userId = session.user.id;
      data.username = session.user.login;
    }
    let n8nEndpoint = env.N8N_API_ENDPOINT;
    if (data.confirmed === true && data.confirmData) {
      n8nEndpoint = env.N8N_API_CONFIRM_ENDPOINT;
      data = { ...data, ...data.confirmData };
    }
    const jwtAlgorithm = env.JWT_ALGORITHM || "HS256";
    const jwtPayload = {
      iss: "kaoqin-system",
      exp: Math.floor(Date.now() / 1e3) + 60 * 5,
      // 5分钟过期
      data
    };
    let jwt;
    if (jwtAlgorithm === "RS256") {
      try {
        const privateKey = env.JWT_PRIVATE_KEY;
        if (!privateKey) {
          throw new Error("RS256\u7B97\u6CD5\u9700\u8981\u914D\u7F6EJWT_PRIVATE_KEY");
        }
        const privateKeyImported = await importPKCS8(privateKey, jwtAlgorithm);
        jwt = await new SignJWT(jwtPayload).setProtectedHeader({ alg: jwtAlgorithm }).sign(privateKeyImported);
      } catch (error) {
        console.error("RS256\u7B7E\u540D\u5931\u8D25:", error);
        return new Response(
          JSON.stringify({ success: false, message: "\u4EE4\u724C\u751F\u6210\u5931\u8D25: " + error.message }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" }
          }
        );
      }
    } else {
      const jwtSecret = env.JWT_SECRET;
      if (!jwtSecret) {
        return createErrorResponse(
          "JWT configuration error: JWT_SECRET is required when using HS256 algorithm",
          500,
          { algorithm: "HS256", missing: ["JWT_SECRET"] }
        );
      }
      if (jwtSecret.length < 32) {
        return createErrorResponse(
          "JWT configuration error: JWT_SECRET must be at least 32 characters long for security",
          500,
          { algorithm: "HS256", secretLength: jwtSecret.length, minimumLength: 32 }
        );
      }
      const secret = new TextEncoder().encode(jwtSecret);
      jwt = await new SignJWT(jwtPayload).setProtectedHeader({ alg: "HS256" }).sign(secret);
    }
    const n8nResponse = await fetch(n8nEndpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${jwt}`
      },
      body: JSON.stringify(data)
    });
    const responseText = await n8nResponse.text();
    let n8nResult;
    try {
      n8nResult = JSON.parse(responseText);
    } catch (error) {
      console.error("n8n\u8FD4\u56DE\u975EJSON\u54CD\u5E94:", responseText);
      return new Response(
        JSON.stringify({
          success: false,
          message: `n8n\u8BA4\u8BC1\u5931\u8D25: ${responseText}`,
          status: n8nResponse.status
        }),
        {
          status: 401,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    if (n8nResult.code && n8nResult.code !== 200) {
      return new Response(
        JSON.stringify({
          success: false,
          message: n8nResult.message || "n8n\u5904\u7406\u5931\u8D25",
          hint: n8nResult.hint,
          code: n8nResult.code
        }),
        {
          status: n8nResult.code,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    return new Response(
      JSON.stringify({
        success: true,
        message: "\u6253\u5361\u6210\u529F",
        data: n8nResult
      }),
      {
        status: 200,
        headers: { "Content-Type": "application/json" }
      }
    );
  } catch (error) {
    console.error("\u5904\u7406\u63D0\u4EA4\u4F4D\u7F6E\u6570\u636E\u5931\u8D25:", error);
    return new Response(
      JSON.stringify({ success: false, message: `\u5904\u7406\u5931\u8D25: ${error.message}` }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}
__name(handleSubmitLocation, "handleSubmitLocation");
async function handleTokenRefresh(context, session) {
  const { env } = context;
  if (!session) {
    return new Response(
      JSON.stringify({ success: false, message: "\u672A\u6388\u6743\u8BBF\u95EE" }),
      {
        status: 401,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
  const jwtAlgorithm = env.JWT_ALGORITHM || "HS256";
  const jwtPayload = {
    iss: "kaoqin-system",
    exp: Math.floor(Date.now() / 1e3) + 60 * 5,
    // 5分钟过期
    data: session.user
  };
  let jwt;
  if (jwtAlgorithm === "RS256") {
    try {
      const privateKey = env.JWT_PRIVATE_KEY;
      if (!privateKey) {
        throw new Error("RS256\u7B97\u6CD5\u9700\u8981\u914D\u7F6EJWT_PRIVATE_KEY");
      }
      const privateKeyImported = await importPKCS8(privateKey, jwtAlgorithm);
      jwt = await new SignJWT(jwtPayload).setProtectedHeader({ alg: jwtAlgorithm }).sign(privateKeyImported);
    } catch (error) {
      console.error("RS256\u7B7E\u540D\u5931\u8D25:", error);
      return new Response(
        JSON.stringify({ success: false, message: "\u4EE4\u724C\u751F\u6210\u5931\u8D25: " + error.message }),
        {
          status: 500,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
  } else {
    try {
      const jwtSecret = env.JWT_SECRET;
      if (!jwtSecret) {
        return createErrorResponse(
          "JWT configuration error: JWT_SECRET is required when using HS256 algorithm",
          500,
          { algorithm: "HS256", missing: ["JWT_SECRET"] }
        );
      }
      if (jwtSecret.length < 32) {
        return createErrorResponse(
          "JWT configuration error: JWT_SECRET must be at least 32 characters long for security",
          500,
          { algorithm: "HS256", secretLength: jwtSecret.length, minimumLength: 32 }
        );
      }
      const secret = new TextEncoder().encode(jwtSecret);
      jwt = await new SignJWT(jwtPayload).setProtectedHeader({ alg: "HS256" }).sign(secret);
    } catch (error) {
      console.error("HS256\u7B7E\u540D\u5931\u8D25:", error);
      return createErrorResponse(
        "JWT token generation failed",
        500,
        { algorithm: "HS256", error: error.message }
      );
    }
  }
  return new Response(
    JSON.stringify({
      success: true,
      token: jwt,
      expiresAt: jwtPayload.exp * 1e3,
      // 转换为毫秒
      algorithm: jwtAlgorithm
      // 返回使用的算法
    }),
    {
      status: 200,
      headers: { "Content-Type": "application/json" }
    }
  );
}
__name(handleTokenRefresh, "handleTokenRefresh");
function handleLogout(context) {
  const headers = new Headers({
    "Location": "/login.html"
  });
  headers.append("Set-Cookie", "session_id=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT");
  return new Response("", {
    status: 302,
    headers
  });
}
__name(handleLogout, "handleLogout");
function handleHealthCheck(context) {
  const { env } = context;
  const healthStatus = {
    status: "healthy",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    version: "1.0.0",
    checks: {}
  };
  const requiredEnvVars = [
    "GITHUB_CLIENT_ID",
    "GITHUB_CLIENT_SECRET",
    "REDIRECT_URI",
    "GITEE_CLIENT_ID",
    "GITEE_CLIENT_SECRET",
    "GITEE_REDIRECT_URI",
    "N8N_API_ENDPOINT",
    "N8N_API_CONFIRM_ENDPOINT"
  ];
  const missingEnvVars = validateRequiredEnvVars(env, requiredEnvVars);
  healthStatus.checks.environment = {
    status: missingEnvVars.length === 0 ? "pass" : "fail",
    missing: missingEnvVars,
    total: requiredEnvVars.length,
    configured: requiredEnvVars.length - missingEnvVars.length
  };
  const jwtErrors = validateJWTConfig(env);
  healthStatus.checks.jwt = {
    status: jwtErrors.length === 0 ? "pass" : "fail",
    algorithm: env.JWT_ALGORITHM || "HS256",
    errors: jwtErrors
  };
  const oauthChecks = {
    github: {
      clientId: !!env.GITHUB_CLIENT_ID,
      clientSecret: !!env.GITHUB_CLIENT_SECRET,
      redirectUri: !!env.REDIRECT_URI && (env.REDIRECT_URI.startsWith("http://") || env.REDIRECT_URI.startsWith("https://"))
    },
    gitee: {
      clientId: !!env.GITEE_CLIENT_ID,
      clientSecret: !!env.GITEE_CLIENT_SECRET,
      redirectUri: !!env.GITEE_REDIRECT_URI && (env.GITEE_REDIRECT_URI.startsWith("http://") || env.GITEE_REDIRECT_URI.startsWith("https://"))
    }
  };
  const oauthStatus = Object.values(oauthChecks.github).every(Boolean) && Object.values(oauthChecks.gitee).every(Boolean);
  healthStatus.checks.oauth = {
    status: oauthStatus ? "pass" : "fail",
    providers: oauthChecks
  };
  const apiEndpointsValid = env.N8N_API_ENDPOINT && env.N8N_API_ENDPOINT.startsWith("https://") && env.N8N_API_CONFIRM_ENDPOINT && env.N8N_API_CONFIRM_ENDPOINT.startsWith("https://");
  healthStatus.checks.apiEndpoints = {
    status: apiEndpointsValid ? "pass" : "fail",
    endpoints: {
      n8nApi: !!env.N8N_API_ENDPOINT,
      n8nConfirm: !!env.N8N_API_CONFIRM_ENDPOINT
    }
  };
  const allChecksPass = Object.values(healthStatus.checks).every((check) => check.status === "pass");
  healthStatus.status = allChecksPass ? "healthy" : "unhealthy";
  const statusCode = allChecksPass ? 200 : 503;
  return createSuccessResponse(healthStatus, statusCode);
}
__name(handleHealthCheck, "handleHealthCheck");

// gitee-login.js
async function onRequest3(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  const returnTo = url.searchParams.get("returnTo") || "/";
  const state = crypto.randomUUID();
  const authUrl = `https://gitee.com/oauth/authorize?client_id=${env.GITEE_CLIENT_ID}&redirect_uri=${encodeURIComponent(env.GITEE_REDIRECT_URI)}&response_type=code&state=${state}`;
  const headers = new Headers({
    "Location": authUrl
  });
  headers.append("Set-Cookie", `gitee_oauth_state=${state}; Path=/; Secure; HttpOnly; Max-Age=600; SameSite=Lax`);
  headers.append("Set-Cookie", `gitee_return_to=${returnTo}; Path=/; Secure; HttpOnly; Max-Age=600; SameSite=Lax`);
  return new Response("", {
    status: 302,
    headers
  });
}
__name(onRequest3, "onRequest");

// login.js
async function onRequest4(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  const returnTo = url.searchParams.get("returnTo") || "/";
  const state = crypto.randomUUID();
  const origin = url.searchParams.get("origin") || "";
  const redirectUris = env.REDIRECT_URI.split(",").map((uri) => uri.trim());
  let redirectUri = redirectUris[0];
  if (origin && redirectUris.length > 1) {
    const matchedUri = redirectUris.find((uri) => uri.includes(origin));
    if (matchedUri) {
      redirectUri = matchedUri;
    }
  }
  const authUrl = `https://github.com/login/oauth/authorize?client_id=${env.GITHUB_CLIENT_ID}&redirect_uri=${encodeURIComponent(redirectUri)}&state=${state}&scope=user:email`;
  const headers = new Headers({
    "Location": authUrl
  });
  headers.append("Set-Cookie", `oauth_state=${state}; Path=/; Secure; HttpOnly; Max-Age=600; SameSite=Lax`);
  headers.append("Set-Cookie", `return_to=${returnTo}; Path=/; Secure; HttpOnly; Max-Age=600; SameSite=Lax`);
  headers.append("Set-Cookie", `selected_redirect_uri=${redirectUri}; Path=/; Secure; HttpOnly; Max-Age=600; SameSite=Lax`);
  return new Response("", {
    status: 302,
    headers
  });
}
__name(onRequest4, "onRequest");

// _middleware.js
async function onRequest5(context) {
  const { request, next, env } = context;
  const url = new URL(request.url);
  const path = url.pathname;
  if (path.startsWith("/api/") || path === "/login" || path === "/gitee-login" || path === "/oauth/callback") {
    return await next();
  }
  if (path === "/" || path === "") {
    const session2 = await getUserSession2(context);
    if (!session2) {
      return new Response("", {
        status: 302,
        headers: {
          "Location": "/login.html"
        }
      });
    }
    return await next();
  }
  if (path === "/login.html") {
    return await next();
  }
  const session = await getUserSession2(context);
  if (!session && !path.startsWith("/public/") && !path.endsWith(".css") && !path.endsWith(".js")) {
    return new Response("", {
      status: 302,
      headers: {
        "Location": "/login.html"
      }
    });
  }
  return await next();
}
__name(onRequest5, "onRequest");
async function getUserSession2(context) {
  const { request, env } = context;
  const cookieHeader = request.headers.get("Cookie") || "";
  const cookies = Object.fromEntries(
    cookieHeader.split("; ").map((c) => {
      const [name, ...value] = c.split("=");
      return [name, value.join("=")];
    })
  );
  const sessionId = cookies.session_id;
  if (!sessionId)
    return null;
  const sessionData = await env.SESSIONS.get(sessionId);
  if (!sessionData)
    return null;
  try {
    const session = JSON.parse(sessionData);
    if (session.expiresAt < Date.now()) {
      await env.SESSIONS.delete(sessionId);
      return null;
    }
    return session;
  } catch (e) {
    return null;
  }
}
__name(getUserSession2, "getUserSession");

// ../.wrangler/tmp/pages-qQrlWT/functionsRoutes-0.8286559043527677.mjs
var routes = [
  {
    routePath: "/oauth/callback",
    mountPath: "/oauth",
    method: "",
    middlewares: [],
    modules: [onRequest]
  },
  {
    routePath: "/api/:routes",
    mountPath: "/api",
    method: "",
    middlewares: [],
    modules: [onRequest2]
  },
  {
    routePath: "/gitee-login",
    mountPath: "/",
    method: "",
    middlewares: [],
    modules: [onRequest3]
  },
  {
    routePath: "/login",
    mountPath: "/",
    method: "",
    middlewares: [],
    modules: [onRequest4]
  },
  {
    routePath: "/",
    mountPath: "/",
    method: "",
    middlewares: [onRequest5],
    modules: []
  }
];

// ../node_modules/path-to-regexp/dist.es2015/index.js
function lexer(str) {
  var tokens = [];
  var i = 0;
  while (i < str.length) {
    var char = str[i];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i, value: str[i++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i, value: str[i++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j = i + 1;
      while (j < str.length) {
        var code = str.charCodeAt(j);
        if (
          // `0-9`
          code >= 48 && code <= 57 || // `A-Z`
          code >= 65 && code <= 90 || // `a-z`
          code >= 97 && code <= 122 || // `_`
          code === 95
        ) {
          name += str[j++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i));
      tokens.push({ type: "NAME", index: i, value: name });
      i = j;
      continue;
    }
    if (char === "(") {
      var count = 1;
      var pattern = "";
      var j = i + 1;
      if (str[j] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j));
      }
      while (j < str.length) {
        if (str[j] === "\\") {
          pattern += str[j++] + str[j++];
          continue;
        }
        if (str[j] === ")") {
          count--;
          if (count === 0) {
            j++;
            break;
          }
        } else if (str[j] === "(") {
          count++;
          if (str[j + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j));
          }
        }
        pattern += str[j++];
      }
      if (count)
        throw new TypeError("Unbalanced pattern at ".concat(i));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i));
      tokens.push({ type: "PATTERN", index: i, value: pattern });
      i = j;
      continue;
    }
    tokens.push({ type: "CHAR", index: i, value: str[i++] });
  }
  tokens.push({ type: "END", index: i, value: "" });
  return tokens;
}
__name(lexer, "lexer");
function parse(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a, _b = options.delimiter, delimiter = _b === void 0 ? "/#?" : _b;
  var result = [];
  var key = 0;
  var i = 0;
  var path = "";
  var tryConsume = /* @__PURE__ */ __name(function(type) {
    if (i < tokens.length && tokens[i].type === type)
      return tokens[i++].value;
  }, "tryConsume");
  var mustConsume = /* @__PURE__ */ __name(function(type) {
    var value2 = tryConsume(type);
    if (value2 !== void 0)
      return value2;
    var _a2 = tokens[i], nextType = _a2.type, index = _a2.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
  }, "mustConsume");
  var consumeText = /* @__PURE__ */ __name(function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  }, "consumeText");
  var isSafe = /* @__PURE__ */ __name(function(value2) {
    for (var _i = 0, delimiter_1 = delimiter; _i < delimiter_1.length; _i++) {
      var char2 = delimiter_1[_i];
      if (value2.indexOf(char2) > -1)
        return true;
    }
    return false;
  }, "isSafe");
  var safePattern = /* @__PURE__ */ __name(function(prefix2) {
    var prev = result[result.length - 1];
    var prevText = prefix2 || (prev && typeof prev === "string" ? prev : "");
    if (prev && !prevText) {
      throw new TypeError('Must have text between two parameters, missing text after "'.concat(prev.name, '"'));
    }
    if (!prevText || isSafe(prevText))
      return "[^".concat(escapeString(delimiter), "]+?");
    return "(?:(?!".concat(escapeString(prevText), ")[^").concat(escapeString(delimiter), "])+?");
  }, "safePattern");
  while (i < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || safePattern(prefix),
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path += value;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? safePattern(prefix) : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
__name(parse, "parse");
function match(str, options) {
  var keys = [];
  var re = pathToRegexp(str, keys, options);
  return regexpToFunction(re, keys, options);
}
__name(match, "match");
function regexpToFunction(re, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.decode, decode = _a === void 0 ? function(x) {
    return x;
  } : _a;
  return function(pathname) {
    var m = re.exec(pathname);
    if (!m)
      return false;
    var path = m[0], index = m.index;
    var params = /* @__PURE__ */ Object.create(null);
    var _loop_1 = /* @__PURE__ */ __name(function(i2) {
      if (m[i2] === void 0)
        return "continue";
      var key = keys[i2 - 1];
      if (key.modifier === "*" || key.modifier === "+") {
        params[key.name] = m[i2].split(key.prefix + key.suffix).map(function(value) {
          return decode(value, key);
        });
      } else {
        params[key.name] = decode(m[i2], key);
      }
    }, "_loop_1");
    for (var i = 1; i < m.length; i++) {
      _loop_1(i);
    }
    return { path, index, params };
  };
}
__name(regexpToFunction, "regexpToFunction");
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
__name(escapeString, "escapeString");
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
__name(flags, "flags");
function regexpToRegexp(path, keys) {
  if (!keys)
    return path;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index = 0;
  var execResult = groupsRegex.exec(path.source);
  while (execResult) {
    keys.push({
      // Use parenthesized substring match if available, index otherwise
      name: execResult[1] || index++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path.source);
  }
  return path;
}
__name(regexpToRegexp, "regexpToRegexp");
function arrayToRegexp(paths, keys, options) {
  var parts = paths.map(function(path) {
    return pathToRegexp(path, keys, options).source;
  });
  return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
__name(arrayToRegexp, "arrayToRegexp");
function stringToRegexp(path, keys, options) {
  return tokensToRegexp(parse(path, options), keys, options);
}
__name(stringToRegexp, "stringToRegexp");
function tokensToRegexp(tokens, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode2 = _d === void 0 ? function(x) {
    return x;
  } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
  var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
  var delimiterRe = "[".concat(escapeString(delimiter), "]");
  var route = start ? "^" : "";
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    if (typeof token === "string") {
      route += escapeString(encode2(token));
    } else {
      var prefix = escapeString(encode2(token.prefix));
      var suffix = escapeString(encode2(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod = token.modifier === "*" ? "?" : "";
            route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
          } else {
            route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
          }
        } else {
          if (token.modifier === "+" || token.modifier === "*") {
            throw new TypeError('Can not repeat "'.concat(token.name, '" without a prefix and suffix'));
          }
          route += "(".concat(token.pattern, ")").concat(token.modifier);
        }
      } else {
        route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
      }
    }
  }
  if (end) {
    if (!strict)
      route += "".concat(delimiterRe, "?");
    route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
    }
    if (!isEndDelimited) {
      route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
    }
  }
  return new RegExp(route, flags(options));
}
__name(tokensToRegexp, "tokensToRegexp");
function pathToRegexp(path, keys, options) {
  if (path instanceof RegExp)
    return regexpToRegexp(path, keys);
  if (Array.isArray(path))
    return arrayToRegexp(path, keys, options);
  return stringToRegexp(path, keys, options);
}
__name(pathToRegexp, "pathToRegexp");

// ../node_modules/wrangler/templates/pages-template-worker.ts
var escapeRegex = /[.+?^${}()|[\]\\]/g;
function* executeRequest(request) {
  const requestPath = new URL(request.url).pathname;
  for (const route of [...routes].reverse()) {
    if (route.method && route.method !== request.method) {
      continue;
    }
    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const matchResult = routeMatcher(requestPath);
    const mountMatchResult = mountMatcher(requestPath);
    if (matchResult && mountMatchResult) {
      for (const handler of route.middlewares.flat()) {
        yield {
          handler,
          params: matchResult.params,
          path: mountMatchResult.path
        };
      }
    }
  }
  for (const route of routes) {
    if (route.method && route.method !== request.method) {
      continue;
    }
    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\$&"), {
      end: true
    });
    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const matchResult = routeMatcher(requestPath);
    const mountMatchResult = mountMatcher(requestPath);
    if (matchResult && mountMatchResult && route.modules.length) {
      for (const handler of route.modules.flat()) {
        yield {
          handler,
          params: matchResult.params,
          path: matchResult.path
        };
      }
      break;
    }
  }
}
__name(executeRequest, "executeRequest");
var pages_template_worker_default = {
  async fetch(originalRequest, env, workerContext) {
    let request = originalRequest;
    const handlerIterator = executeRequest(request);
    let data = {};
    let isFailOpen = false;
    const next = /* @__PURE__ */ __name(async (input, init) => {
      if (input !== void 0) {
        let url = input;
        if (typeof input === "string") {
          url = new URL(input, request.url).toString();
        }
        request = new Request(url, init);
      }
      const result = handlerIterator.next();
      if (result.done === false) {
        const { handler, params, path } = result.value;
        const context = {
          request: new Request(request.clone()),
          functionPath: path,
          next,
          params,
          get data() {
            return data;
          },
          set data(value) {
            if (typeof value !== "object" || value === null) {
              throw new Error("context.data must be an object");
            }
            data = value;
          },
          env,
          waitUntil: workerContext.waitUntil.bind(workerContext),
          passThroughOnException: () => {
            isFailOpen = true;
          }
        };
        const response = await handler(context);
        if (!(response instanceof Response)) {
          throw new Error("Your Pages function should return a Response");
        }
        return cloneResponse(response);
      } else if ("ASSETS") {
        const response = await env["ASSETS"].fetch(request);
        return cloneResponse(response);
      } else {
        const response = await fetch(request);
        return cloneResponse(response);
      }
    }, "next");
    try {
      return await next();
    } catch (error) {
      if (isFailOpen) {
        const response = await env["ASSETS"].fetch(request);
        return cloneResponse(response);
      }
      throw error;
    }
  }
};
var cloneResponse = /* @__PURE__ */ __name((response) => (
  // https://fetch.spec.whatwg.org/#null-body-status
  new Response(
    [101, 204, 205, 304].includes(response.status) ? null : response.body,
    response
  )
), "cloneResponse");
export {
  pages_template_worker_default as default
};

------formdata-undici-006884689923--